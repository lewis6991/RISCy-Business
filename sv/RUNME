#!/bin/bash

#----------------------------------------
# File: RUNME.sh
# Description: Bash script for automated testing
# Primary Author: Jack Barnes
# Other Contributors: Dominic Murphy
# Notes:
#----------------------------------------

main()
{
    if [ ${#} = "0" ]
    then
        RUN_PROC=1
    fi
    while [ "$1" != "" ]; do
        case $1 in
            (-h|--help)     usage;;
            (-a|--all)      RUN_IF=1
                            RUN_ID=1
                            RUN_EX=1
                            RUN_MEM=1
                            RUN_WB=1
                            RUN_FU=1
                            RUN_BP=1
                            RUN_PROC=1;;
            (-proc)         RUN_PROC=1;;
            (-if)           RUN_IF=1;;
            (-id)           RUN_ID=1;;
            (-ex)           RUN_EX=1;;
            (-mem)          RUN_MEM=1;;
            (-wb)           RUN_WB=1;;
            (-fu)           RUN_FU=1;;
            (-bp)           RUN_BP=1;;
            (--specific=*)  SPECIFIC="$SPECIFIC ${1//"--specific="/}";;
            (-s=*)          SPECIFIC="$SPECIFIC ${1//"-s="/}";;
            (-gui)          GUI_VAR="+gui"
                            echo "Include GUI";;
            (-q|--quiet)    QUIET=1;;
            (-plusargs=*)   PLUSARGS=${1//"-plusargs="/};;
            (-syn)          RUN_SYN=1;;
            (-pnr)          RUN_PNR=1;;
            (-*)            echo "Unknown argument. Try --help for information";;
            (*)             echo "No arguments defined";;
        esac
        shift
    done

    if [ -n "$SPECIFIC" ]
    then
        specific
    fi
    if [ -n "$RUN_IF" ]
    then
        MODULES=(pcinc pc IF)
        stages "IF"
    fi
    if [ -n "$RUN_ID" ]
    then
        MODULES=(decoder registers signextend)
        stages "ID"
    fi
    if [ -n "$RUN_EX" ]
    then
        MODULES=(alu acc_control ex_mult ex_control EX)
        stages "EX"
    fi
    if [ -n "$RUN_MEM" ]
    then
        MODULES=(MEM)
        stages "MEM"
    fi
    if [ -n "$RUN_WB" ]
    then
        MODULES=(mux)
        stages "WB"
    fi
    if [ -n "$RUN_FU" ]
    then
        MODULES=(FU)
        stages "FU"
    fi
    if [ -n "$RUN_BP" ]
    then
        MODULES=(BP)
        stages "BP"
    fi
    if [ -n "$RUN_PROC" ]
    then
        proc
    fi
    if [ -n "$RUN_SYN" ]
    then
        PROCLOC="test/processor_tb.sv syn/processor_synth.v syn/0.35um_Technologu_HDL_Files/*.v"
        proc
    fi
    if [ -n "$RUN_PNR" ]
    then
        PROCLOC="test/processor_tb.sv syn/processor_net.v syn/0.35um_Technologu_HDL_Files/*.v"
        proc
    fi




    padding
    echo -e "\n$newtext" >> run.log
    echo -e "\n$newtext"

    exit 0
}

usage()
{
    echo "
    -h,--help          Displays this message
    -a,--all           Runs all test conditions
    -proc              Runs the top level processor test
    -if                Runs the instruction fetch tests
    -id                Runs the instruction decode tests
    -ex                Runs the execute tests
    -mem               Runs the memory tests
    -wb                Runs the write back tests
    -fu                Runs the forwarding unit test
    -bp                Runs the branch prediction test
    -s,--specific=\"\"   Runs a singular test on 'module'
    -gui               Runs the gui
    -q,--quiet         Runs the tests with little feedback.
                       Default case shows errors within module tests
    -syn               Runs the test cases on the synthesised design
    -pnr               Runs the test cases on the placed and routed design
     NO ARGUMENT       Runs the top level processor test (Without GUI)

    -plusargs=\"\"       Include plusargs to any command to set arguments
                       within the testbench itself. Full list below.
                       Arguments can be chained by including a single
                       comma between them. Left blank if not set
        \"+test=<>\"     Used within the top level processor to choose
                       the testcase
    "
    exit 1
}

proc()
{
    echo "##### Testing the entire processor"
    if [[ $PLUSARGS = *"+test"* ]]
    then
        ncverilog $NC_ARGS $GUI_VAR "+incdir+src/+test/" $PLUSARGS $PROCLOC >> run.log
        if [ "$?" = "0" ]
        then
            summarytext=$"${summarytext}processor testcase ${PLUSARGS//"+test="/} .. PASS
"
        else
            summarytext=$"${summarytext}processor testcase ${PLUSARGS//"+test="/} .. FAIL
"
            if [ -z "$QUIET" ]
            then
                ncverilog $NC_ARGS "+incdir+src/+test/" $PLUSARGS $PROCLOC
            fi
        fi
    else
        for test in {1..4}
        do
            ncverilog $NC_ARGS $GUI_VAR "+incdir+src/+test/" $PLUSARGS "+test="$test $PROCLOC >> run.log
            if [ "$?" = "0" ]
            then
                summarytext="${summarytext}processor testcase $test .. PASS
"
            else
                summarytext="${summarytext}processor testcase $test .. FAIL
"
                if [ -z "$QUIET" ]
                then
                    ncverilog $NC_ARGS "+incdir+src/+test/" $PLUSARGS "+test="$test $PROCLOC
                fi
            fi
        done
    fi
    echo "      .. done"
}

stages()
{
    echo "##### Testing the $1 stage"
    for i in ${MODULES[@]};
    do
        echo "  ### Testing ${i}.sv"
        ncverilog $NC_ARGS $GUI_VAR +incdir+src/ $PLUSARGS "test/${i}_tb.sv" src/${i}.sv >> run.log
        if [ "$?" = "0" ]
        then
            summarytext="${summarytext}$i .. PASS
"
        else
            summarytext="${summarytext}$i .. FAIL
"
            if [ -z "$QUIET" ]
            then
                ncverilog $NC_ARGS +incdir+src/ $PLUSARGS "test/${i}_tb.sv" src/${i}.sv
            fi
        fi
        echo "      .. done"
    done
    echo "##### .. done"
}

specific()
{
    for i in ${SPECIFIC[@]}
    do
        echo "##### Testing ${i}.sv"
        ncverilog $NC_ARGS $GUI_VAR +incdir+src/ $PLUSARGS "test/${i}_tb.sv" src/${i}.sv >> run.log
        if [ "$?" = "0" ]
        then
            summarytext="${summarytext}$i .. PASS
"
        else
            summarytext="${summarytext}$i .. FAIL
"
            if [ -z "$QUIET" ]
            then
                ncverilog $NC_ARGS +incdir+src/ $PLUSARGS "test/${i}_tb.sv" src/${i}.sv
            fi
        fi
        echo "      .. done"
    done
}

padding()
{
    while read a
    do
       declare -i NUMCS
       TOTAL=${#a}
       NUMCS=$TOTAL
       if [ $NUMCS -gt 8 ]
       then
           NUMCS=$NUMCS-8
           newtext="${newtext}${a:0:$NUMCS} "
           for (( j=1; j<=14-$NUMCS; j++ ))
           do
               newtext="${newtext}."
           done
           newtext="${newtext} ${a:$TOTAL-4:$TOTAL}\n"
       fi
    done <<< "$summarytext"
}

echo -e 'run.log
' > run.log
summarytext=""
newtext=""
PROCLOC="test/processor_tb.sv src/*.sv"
NC_ARGS="+nc64bit +ncaccess+r -sv -w -q +nctimescale+1ns/10ps"
main "$@"






